# Authentication Structure

## Definitions
* **Properties**: name-value pairs
* **Hash:** Cryptographic hash of properties
* **Token:** Encrypted token using key
* **Signature:** An encrypted copy of a request, used to verify that the issuer of the request is in possession of a private key
* **App-A-Private-Key:** Private key owned only by Application A
* **App-A-Public-Key****:** Public key corresponding to **App-A-Private-Key** that is possessed by IDS. Used to verify requests from Application A, and to send encrypted data to Application A
* **IDS-App-Auth-Private-Key:** Private key, owned by IDS, which is used exclusively so other applications can verify another application's Login Token.
* **IDS-App-Auth-Public-Key: **Public key, paired with **IDS-App-Auth-Private-Key**, possessed by all applications, which allows for authenticating requests from other applications who authenticated using IDS
* **App-A-Login-Token:** Token generated by IDS that specifies it was generated by IDS for Application A.  Token is encrypted using **IDS-App-Auth-Private-Key****.**
  * Properties: 
    * <span style="color: rgb(0,0,255);">**Application ID**</span> (Identifier for application the token was issued for, ie "Application A" or some other unique ID)
    * <span style="color: rgb(0,0,255);">**Expiration Date**</span> (Built-in time that the token expires.  For applications, this can be long-lived.  If it's short lived, the applications will need to periodically hit IDS to be issued a new token)
* **App-A-Auth-Token:** Token returned by IDS when Application A attempts to authenticate for the first time.  This token will contain the **App-A-Login-Token** as a property. This is encrypted using **App-A-Public-Key** so that only Application A can decrypt and extract values.
    * Properties:
      * <span style="color: rgb(0,0,255);">**App-A-Login-Token**</span> (The actual token that Application A should pass when calling other applications)
* **App-A-User-Auth-Token:** Token generated by IDS, which contains the **User-Auth-Token** and is encrypted using **App-A-Public-Key**
  * Properties:
    * <span style="color: rgb(0,0,255);">**User-Auth-Token**</span> (The actual token used to identify the user and prove they've been authenticated when calling other applications)
* **User-Login-Token:** Token generated by IDS which is only for IDS's internal use for when a user hits the IDS service.  This should be stored and encrypted in a way such that only IDS can access it or read from it, to prevent other applications from impersonating a user in an unauthorized way.
  * Properties:
    * <span style="color: rgb(0,0,255);">**User Identifier**</span> (The unique ID of the user)
    * <span style="color: rgb(0,0,255);">**Expiration**</span> (Built-in time that the token expires)
    * <span style="color: rgb(0,0,255);">**Issuer(s)**</span> (The application the token was issued for.  If multiple applications send the user to IDS, this could contain multiple values)
    * Any other properties IDS would want to track for the user
* **User-Auth-Token:** Token generated by IDS, to provides a user's identity and proves that they've authenticated.  Token is encrypted using **IDS-App-Auth-Private-Key** so that applications can decrypt using **IDS-App-Auth-Public-Key** to get the user's identity, and also know that this user has authenticated through IDS.
  * Properties:
    * <span style="color: rgb(0,0,255);">**User Identifier**</span> (The unique ID of the user)
    * **<span style="color: rgb(0,0,255);">Expiration</span>** <span style="color: rgb(0,0,0);">(Built-in time that the token expires)</span>

## Flows

### Service Authentication
1. App A, on startup, makes server-to-server call to IDS requesting an <u>App-A-Auth-Token</u>
  * Request contains a <u>signature</u> signed using <u>App-A-Private-Key</u>
  * IDS verifies request came from App-A by using <u>App-A-Public-Key</u> to validate request and signature pair
2. IDS generates an <u>App-A-Login-Token</u>
  * Token contains property saying that this is Application A
  * Token is encrypted using <u>IDS-App-Auth-Private-Key</u>
3. IDS generates an <u>App-A-Auth-Token</u> which is returned to App A
  * Auth Token contains the <u>App-A-Login-Token</u>
  * Token is encrypted using <u>App-A-Public-Key</u> so that only Application A can decrypt the value and extract the <u>App-A-Login-Token</u>
4. App A can now extract the <u>App-A-Login-Token</u> and store it locally.  It will need this for all calls to other applications, and for some calls to the IDS.

### User Authentication
1. User X requests a resource in App A
2. App A checks to see if User X is authenticated
  * It is up to each Application how it chooses to manage this (ie an App-A-specific Cookie that is read only by App A, which signifies that this is User X and they're authenticated)
3. If user is not authenticated, redirect them to the IDS (via browser) passing the <u>App-A-Login-Token</u>
  * <span style="color: rgb(255,0,0);">QUESTION: Do we need to add some authentication to ensure that user came from Application A?</span>
4. IDS checks if <u>App-A-Login-Token</u> is valid
5. IDS checks if user is authenticated
  * Authenticated -> Continue with flow
  * Not authenticated
    * Prompt for user credentials.Ensure user enters valid credentials, User is authenticated.
    * Generate a <u>User-Login-Token</u> that is stored in a cookie that only IDS can read from.  This allows for the user to re-authenticate through IDS without having to enter their credentials again.
      * IDS can put any properties it needs to in this token, including user's identity, a timestamp when the token will expire, etc.
    * Generate a <u>User-Auth-Token</u>, which contains the user's unique identifier, and which is encrypted using <u>IDS_App-Auth-Private-Key</u>
    * Encrypt the <u>User-Auth-Token</u> into an <u>App-A-User-Auth-Token</u> using <u>App-A-Public-Key</u> so that only Application A can decrypt this request to extract the <u>User-Auth-Token</u> and get the user's identity.
6. Once user has authenticated, POST <u>App-A-User-Auth-Token</u> back to Application A
7. Application A can now verify the user has been authenticated by IDS (by successfully decrypting the <u>User-Auth-Token</u> using the <u>IDS-App-Auth-Public-Key</u>).  
  * Application A can now store the the <u>App-A-User-Auth-Token</u> in a cookie to establish a user "session" and avoid having to make unnecessary round trips back to the IDS service.
  * <span style="color: rgb(255,0,0);">IMPORTANT: It is critical that the Application only ever "cache" the <u>App-A-User-Auth-Token</u> and NOT the <u>User-Auth-Token</u>.  This ensures the token cannot be tampered with, and that the cached "session" token can only be used in calls to Application A (since only Application A can decrypt it)</span>

### App-to-App requests on behalf of a user
1. Application A starts up and follows the steps in Service startup
2. When User X reaches Application A, Application A ensures user is authenticated following steps in **User authentication**
3. Application A makes a request to Application B on behalf of User X
  * Application A Passes the the <u>App-A-Login-Token</u> and <u>User-Auth-Token</u> to Application B as part of the request
4. Application B receives requests and tries to first authenticate Application A
  * Application B can decrypt the <u>App-A-Login-Token</u> to verify that the token was created by IDS, and can verify that the token was for Application A by inspecting the properties of the decrypted token
5. Application B can then try to authenticate User X
  * Application B can decrypt the <u>User-Auth-Token</u> to verify the token was created by IDS, and can verify that the identity inside of the token is User X by inspecting the properties of the decrypted token
  * Application B can also verify that the user token isn't expired, and/or it meets all the authorization levels required for App B
6. If Application B is able to verify the caller (Application A) and the user (User X) it can now trust this call and execute the code path
  * If Application B needs to call another application (ie Application C) it should pass its own <u>App-B-Login-Token</u> and the received <u>User-Auth-Token</u> by following the same steps that Application A took to call Application B
