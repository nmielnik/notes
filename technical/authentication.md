# Authentication Structure

## Definitions
* **Properties**: name-value pairs
* **Hash:** Cryptographic hash of properties
* **Token:** Encrypted token using key
* **Signature:** An encrypted copy of a request, used to verify that the issuer of the request is in possession of a private key
* **App-A-Private-Key:** Private key owned only by Application A
* **App-A-Public-Key****:** Public key corresponding to **App-A-Private-Key** that is possessed by IDS. Used to verify requests from Application A, and to send encrypted data to Application A
* **IDS-App-Auth-Private-Key:** Private key, owned by IDS, which is used exclusively so other applications can verify another application's Login Token.
* **IDS-App-Auth-Public-Key: **Public key, paired with **IDS-App-Auth-Private-Key**, possessed by all applications, which allows for authenticating requests from other applications who authenticated using IDS
* **App-A-Login-Token:** Token generated by IDS that specifies it was generated by IDS for Application A.  Token is encrypted using **IDS-App-Auth-Private-Key****.**
  * Properties: 
    * _**Application ID**_ (Identifier for application the token was issued for, ie "Application A" or some other unique ID)
    * _**Expiration Date**_ (Built-in time that the token expires.  For applications, this can be long-lived.  If it's short lived, the applications will need to periodically hit IDS to be issued a new token)
* **App-A-Auth-Token:** Token returned by IDS when Application A attempts to authenticate for the first time.  This token will contain the **App-A-Login-Token** as a property. This is encrypted using **App-A-Public-Key** so that only Application A can decrypt and extract values.
    * Properties:
      * _**App-A-Login-Token**_ (The actual token that Application A should pass when calling other applications)
* **App-A-User-Auth-Token:** Token generated by IDS, which contains the **User-Auth-Token** and is encrypted using **App-A-Public-Key**
  * Properties:
    * _**User-Auth-Token**_ (The actual token used to identify the user and prove they've been authenticated when calling other applications)
* **User-Login-Token:** Token generated by IDS which is only for IDS's internal use for when a user hits the IDS service.  This should be stored and encrypted in a way such that only IDS can access it or read from it, to prevent other applications from impersonating a user in an unauthorized way.
  * Properties:
    * _**User Identifier**_ (The unique ID of the user)
    * _**Expiration**_ (Built-in time that the token expires)
    * _**Issuer(s)**_ (The application the token was issued for.  If multiple applications send the user to IDS, this could contain multiple values)
    * Any other properties IDS would want to track for the user
* **User-Auth-Token:** Token generated by IDS, to provides a user's identity and proves that they've authenticated.  Token is encrypted using **IDS-App-Auth-Private-Key** so that applications can decrypt using **IDS-App-Auth-Public-Key** to get the user's identity, and also know that this user has authenticated through IDS.
  * Properties:
    * _**User Identifier**_ (The unique ID of the user)
    * _**Expiration**_ (Built-in time that the token expires)_

## Flows

### Service Authentication
1. App A, on startup, makes server-to-server call to IDS requesting an _App-A-Auth-Token_
  * Request contains a _signature_ signed using _App-A-Private-Key_
  * IDS verifies request came from App-A by using _App-A-Public-Key_ to validate request and signature pair
2. IDS generates an _App-A-Login-Token_
  * Token contains property saying that this is Application A
  * Token is encrypted using _IDS-App-Auth-Private-Key_
3. IDS generates an _App-A-Auth-Token_ which is returned to App A
  * Auth Token contains the _App-A-Login-Token_
  * Token is encrypted using _App-A-Public-Key_ so that only Application A can decrypt the value and extract the _App-A-Login-Token_
4. App A can now extract the _App-A-Login-Token_ and store it locally.  It will need this for all calls to other applications, and for some calls to the IDS.

### User Authentication
1. User X requests a resource in App A
2. App A checks to see if User X is authenticated
  * It is up to each Application how it chooses to manage this (ie an App-A-specific Cookie that is read only by App A, which signifies that this is User X and they're authenticated)
3. If user is not authenticated, redirect them to the IDS (via browser) passing the _App-A-Login-Token_
  * _**QUESTION:** Do we need to add some authentication to ensure that user came from Application A?_
4. IDS checks if _App-A-Login-Token_ is valid
5. IDS checks if user is authenticated
  * Authenticated -> Continue with flow
  * Not authenticated
    * Prompt for user credentials.Ensure user enters valid credentials, User is authenticated.
    * Generate a _User-Login-Token_ that is stored in a cookie that only IDS can read from.  This allows for the user to re-authenticate through IDS without having to enter their credentials again.
      * IDS can put any properties it needs to in this token, including user's identity, a timestamp when the token will expire, etc.
    * Generate a _User-Auth-Token_, which contains the user's unique identifier, and which is encrypted using _IDS_App-Auth-Private-Key_
    * Encrypt the _User-Auth-Token_ into an _App-A-User-Auth-Token_ using _App-A-Public-Key_ so that only Application A can decrypt this request to extract the _User-Auth-Token_ and get the user's identity.
6. Once user has authenticated, POST _App-A-User-Auth-Token_ back to Application A
7. Application A can now verify the user has been authenticated by IDS (by successfully decrypting the _User-Auth-Token_ using the _IDS-App-Auth-Public-Key_).  
  * Application A can now store the the _App-A-User-Auth-Token_ in a cookie to establish a user "session" and avoid having to make unnecessary round trips back to the IDS service.
  * _**IMPORTANT:** It is critical that the Application only ever "cache" the _App-A-User-Auth-Token_ and NOT the _User-Auth-Token_.  This ensures the token cannot be tampered with, and that the cached "session" token can only be used in calls to Application A (since only Application A can decrypt it)_

### App-to-App requests on behalf of a user
1. Application A starts up and follows the steps in Service startup
2. When User X reaches Application A, Application A ensures user is authenticated following steps in **User authentication**
3. Application A makes a request to Application B on behalf of User X
  * Application A Passes the the _App-A-Login-Token_ and _User-Auth-Token_ to Application B as part of the request
4. Application B receives requests and tries to first authenticate Application A
  * Application B can decrypt the _App-A-Login-Token_ to verify that the token was created by IDS, and can verify that the token was for Application A by inspecting the properties of the decrypted token
5. Application B can then try to authenticate User X
  * Application B can decrypt the _User-Auth-Token_ to verify the token was created by IDS, and can verify that the identity inside of the token is User X by inspecting the properties of the decrypted token
  * Application B can also verify that the user token isn't expired, and/or it meets all the authorization levels required for App B
6. If Application B is able to verify the caller (Application A) and the user (User X) it can now trust this call and execute the code path
  * If Application B needs to call another application (ie Application C) it should pass its own _App-B-Login-Token_ and the received _User-Auth-Token_ by following the same steps that Application A took to call Application B
